/*
 * MangaDex API
 *
 * MangaDex is an ad-free manga reader offering high-quality images!  This document details our API as it is right now. It is in no way a promise to never change it, although we will endeavour to publicly notify any major change.  # Acceptable use policy  Usage of our services implies acceptance of the following: - You **MUST** credit us - You **MUST** credit scanlation groups if you offer the ability to read chapters - You **CANNOT** run ads or paid services on your website and/or apps  These may change at any time for any and no reason and it is up to you check for updates from time to time.  # Security issues  If you believe you found a security issue in our API, please check our [security.txt](/security.txt) to get in touch privately.
 *
 * API version: 5.9.0
 * Contact: support@mangadex.org
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package mangadex

import (
	"context"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type MangaApiService service

/*
MangaApiService Tag list
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return TagResponse
*/
func (a *MangaApiService) GetMangaTag(ctx context.Context) (TagResponse, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue TagResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/manga/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TagResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MangaApiService Manga list
Search a list of Manga.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *MangaApiGetSearchMangaOpts - Optional Parameters:
     * @param "Limit" (optional.Int32) -
     * @param "Offset" (optional.Int32) -
     * @param "Title" (optional.String) -
     * @param "AuthorOrArtist" (optional.Interface of string) -
     * @param "Authors" (optional.Interface of []string) -
     * @param "Artists" (optional.Interface of []string) -
     * @param "Year" (optional.Int32) -  Year of release
     * @param "IncludedTags" (optional.Interface of []string) -
     * @param "IncludedTagsMode" (optional.String) -
     * @param "ExcludedTags" (optional.Interface of []string) -
     * @param "ExcludedTagsMode" (optional.String) -
     * @param "Status" (optional.Interface of []string) -
     * @param "OriginalLanguage" (optional.Interface of []string) -
     * @param "ExcludedOriginalLanguage" (optional.Interface of []string) -
     * @param "AvailableTranslatedLanguage" (optional.Interface of []string) -
     * @param "PublicationDemographic" (optional.Interface of []string) -
     * @param "Ids" (optional.Interface of []string) -  Manga ids (limited to 100 per request)
     * @param "ContentRating" (optional.Interface of []string) -
     * @param "CreatedAtSince" (optional.String) -
     * @param "UpdatedAtSince" (optional.String) -
     * @param "OrderTitle" (optional.String) -
     * @param "OrderYear" (optional.String) -
     * @param "OrderCreatedAt" (optional.String) -
     * @param "OrderUpdatedAt" (optional.String) -
     * @param "OrderLatestUploadedChapter" (optional.String) -
     * @param "OrderFollowedCount" (optional.String) -
     * @param "OrderRelevance" (optional.String) -
     * @param "OrderRating" (optional.String) -
     * @param "Includes" (optional.Interface of []string) -
     * @param "HasAvailableChapters" (optional.String) -
     * @param "Group" (optional.Interface of string) -
@return MangaList
*/

type MangaApiGetSearchMangaOpts struct {
	Limit                       optional.Int32
	Offset                      optional.Int32
	Title                       optional.String
	AuthorOrArtist              optional.Interface
	Authors                     optional.Interface
	Artists                     optional.Interface
	Year                        optional.Int32
	IncludedTags                optional.Interface
	IncludedTagsMode            optional.String
	ExcludedTags                optional.Interface
	ExcludedTagsMode            optional.String
	Status                      optional.Interface
	OriginalLanguage            optional.Interface
	ExcludedOriginalLanguage    optional.Interface
	AvailableTranslatedLanguage optional.Interface
	PublicationDemographic      optional.Interface
	Ids                         optional.Interface
	ContentRating               optional.Interface
	CreatedAtSince              optional.String
	UpdatedAtSince              optional.String
	OrderTitle                  optional.String
	OrderYear                   optional.String
	OrderCreatedAt              optional.String
	OrderUpdatedAt              optional.String
	OrderLatestUploadedChapter  optional.String
	OrderFollowedCount          optional.String
	OrderRelevance              optional.String
	OrderRating                 optional.String
	Includes                    optional.Interface
	HasAvailableChapters        optional.String
	Group                       optional.Interface
}

func (a *MangaApiService) GetSearchManga(ctx context.Context, localVarOptionals *MangaApiGetSearchMangaOpts) (MangaList, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue MangaList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/manga"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Title.IsSet() {
		localVarQueryParams.Add("title", parameterToString(localVarOptionals.Title.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthorOrArtist.IsSet() {
		localVarQueryParams.Add("authorOrArtist", parameterToString(localVarOptionals.AuthorOrArtist.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Authors.IsSet() {
		localVarQueryParams.Add("authors[]", parameterToString(localVarOptionals.Authors.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Artists.IsSet() {
		localVarQueryParams.Add("artists[]", parameterToString(localVarOptionals.Artists.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Year.IsSet() {
		localVarQueryParams.Add("year", parameterToString(localVarOptionals.Year.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludedTags.IsSet() {
		// todo: future self, can we make arrays be smarter?
		// todo: had to convert this to properly set the array value...
		tags := localVarOptionals.IncludedTags.Value().([]string)
		for _, tag := range tags {
			localVarQueryParams.Add("includedTags[]", parameterToString(tag, ""))
		}
		//localVarQueryParams.Add("includedTags[]", parameterToString(localVarOptionals.IncludedTags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.IncludedTagsMode.IsSet() {
		localVarQueryParams.Add("includedTagsMode", parameterToString(localVarOptionals.IncludedTagsMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludedTags.IsSet() {
		// todo: future self, can we make arrays be smarter?
		// todo: had to convert this to properly set the array value...
		tags := localVarOptionals.IncludedTags.Value().([]string)
		for _, tag := range tags {
			localVarQueryParams.Add("excludedTags[]", parameterToString(tag, ""))
		}
		//localVarQueryParams.Add("excludedTags[]", parameterToString(localVarOptionals.ExcludedTags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludedTagsMode.IsSet() {
		localVarQueryParams.Add("excludedTagsMode", parameterToString(localVarOptionals.ExcludedTagsMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status[]", parameterToString(localVarOptionals.Status.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.OriginalLanguage.IsSet() {
		localVarQueryParams.Add("originalLanguage[]", parameterToString(localVarOptionals.OriginalLanguage.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludedOriginalLanguage.IsSet() {
		localVarQueryParams.Add("excludedOriginalLanguage[]", parameterToString(localVarOptionals.ExcludedOriginalLanguage.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.AvailableTranslatedLanguage.IsSet() {
		localVarQueryParams.Add("availableTranslatedLanguage[]", parameterToString(localVarOptionals.AvailableTranslatedLanguage.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.PublicationDemographic.IsSet() {
		localVarQueryParams.Add("publicationDemographic[]", parameterToString(localVarOptionals.PublicationDemographic.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Ids.IsSet() {
		localVarQueryParams.Add("ids[]", parameterToString(localVarOptionals.Ids.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.ContentRating.IsSet() {
		localVarQueryParams.Add("contentRating[]", parameterToString(localVarOptionals.ContentRating.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedAtSince.IsSet() {
		localVarQueryParams.Add("createdAtSince", parameterToString(localVarOptionals.CreatedAtSince.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdatedAtSince.IsSet() {
		localVarQueryParams.Add("updatedAtSince", parameterToString(localVarOptionals.UpdatedAtSince.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderTitle.IsSet() {
		localVarQueryParams.Add("order[title]", parameterToString(localVarOptionals.OrderTitle.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderYear.IsSet() {
		localVarQueryParams.Add("order[year]", parameterToString(localVarOptionals.OrderYear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderCreatedAt.IsSet() {
		localVarQueryParams.Add("order[createdAt]", parameterToString(localVarOptionals.OrderCreatedAt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderUpdatedAt.IsSet() {
		localVarQueryParams.Add("order[updatedAt]", parameterToString(localVarOptionals.OrderUpdatedAt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderLatestUploadedChapter.IsSet() {
		localVarQueryParams.Add("order[latestUploadedChapter]", parameterToString(localVarOptionals.OrderLatestUploadedChapter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderFollowedCount.IsSet() {
		localVarQueryParams.Add("order[followedCount]", parameterToString(localVarOptionals.OrderFollowedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderRelevance.IsSet() {
		localVarQueryParams.Add("order[relevance]", parameterToString(localVarOptionals.OrderRelevance.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderRating.IsSet() {
		localVarQueryParams.Add("order[rating]", parameterToString(localVarOptionals.OrderRating.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Includes.IsSet() {
		// todo: future self, can we make arrays be smarter?
		// todo: had to convert this to properly set the array value...
		includes := localVarOptionals.Includes.Value().([]string)
		for _, include := range includes {
			localVarQueryParams.Add("includes[]", parameterToString(include, ""))
		}
		//localVarQueryParams.Add("includes[]", parameterToString(localVarOptionals.Includes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HasAvailableChapters.IsSet() {
		localVarQueryParams.Add("hasAvailableChapters", parameterToString(localVarOptionals.HasAvailableChapters.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Group.IsSet() {
		localVarQueryParams.Add("group", parameterToString(localVarOptionals.Group.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}
	//fmt.Println(localVarHttpResponse.Header)
	//fmt.Println("X-RateLimit-Limit: " + localVarHttpResponse.Header.Get("X-RateLimit-Limit"))
	//fmt.Println("X-RateLimit-Remaining: " + localVarHttpResponse.Header.Get("X-RateLimit-Remaining"))
	//fmt.Println("X-RateLimit-Retry-After: " + localVarHttpResponse.Header.Get("X-RateLimit-Retry-After"))

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v MangaList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
